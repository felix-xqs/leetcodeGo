package kth_smallest_element_in_a_sorted_matrix

/*
378. 有序矩阵中第K小的元素 https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/
给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。

示例：
matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

返回 13。

提示：
你可以假设 k 的值永远是有效的，1 ≤ k ≤ n2 。
*/
/*
可以先看看74、240两个问题，在有序矩阵里找到查找一个元素，比当前这个问题简单些，有助于当前问题的解决
比如在当前这种类型的矩阵里寻找一个数字，返回其位置，怎么做呢？

以题目给的示例矩阵为例，在其中搜索元素10
可以从左下角的12开始，也可以从右上角的9开始，为什么从左下角或右上角开始？看完下边的搜索逻辑就知道了：
不妨从右上角开始，发现目标10比当前元素9大，那么可以向下走一步（向左走没有意义，左边的元素比9还小）到达13，比目标大，那么向左走（同理不能向下走）
。。。
可以看到，根据这样的策略去查找，尽可能第利用了矩阵已经排序的特性，找到一个元素，最坏情况是走n+1步，其中n是矩阵边长
也就是时间复杂度是O(n)
现在就可以回想下为什么一开始选左下角或右上角的问题了，比较容易明白。如果选左上角或右下角，用不了上面每一步的策略。

回到这个问题：需要找到第k小的数字
1. 首先容易发现，这样的矩阵最小、最大元素分别在左上角和右下角；答案就在这个[min, max]区间内
2. 既然答案有范围，这里可以用二分法去猜，对于每一个mid，在矩阵里统计一下小于等于mid的数字有多少个，
如果比k小，说明猜小了，如果比k大说明猜大了；根据这个决定left指针移动还是right指针移动
3. 怎么比较快速地统计出矩阵中小于等于目标的数字个数呢？这可以用到上面提到的从右上角或左下角出发查找数字的技巧
以示例所给的矩阵为例，最小值1，最大值15，首先我们统计下中间数8，矩阵中小于等于8的数字有多少个呢？
从右上角出发，9比8大，向左走一步，5比8小，向下走一步，同时将5及其左侧的数字的个数（5和1共2个）累加到结果
11比8大，向左走，10比8大，向左走，出界，结束
最后统计到小于等于8的数字有2个，这比需要的k=8小，说明这次猜小了，现在开始猜9和15的中间数,12
统计方法同第一次，不赘述

时间复杂度O(n*lg(max-min)), 空间复杂度O(1)
*/
func kthSmallest(matrix [][]int, k int) int {
	n := len(matrix)
	left, right := matrix[0][0], matrix[n-1][n-1]
	for left < right {
		mid := left + (right-left)/2
		lowersCount := count(matrix, mid)
		if lowersCount < k {
			left = mid + 1
		} else {
			right = mid
		}
	}
	return left
}

func count(matrix [][]int, v int) int {
	result := 0
	r, c := 0, len(matrix)-1
	for r < len(matrix) && c >= 0 {
		if matrix[r][c] > v {
			c--
		} else {
			result += c + 1
			r++
		}
	}
	return result
}
