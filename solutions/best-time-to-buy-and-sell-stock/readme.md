# 股票收益问题
## 参考
这里介绍一个通用的解法<br>
参考：[一个通用的方法团灭6道股票问题](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/)

## dp穷举
定义dp[i][k][s]表示第i天，交易了k次，持有或不持有股票所能得到的最大收益<br>
假设共n天，最大交易次数为m，则所有的状态共（n * m * 2）种
```
for 0 <= i < n {
    for 1 <= k <= m {
        for 0 <= s <= 1 {
            dp[i][k][s] = max(buy, sell, rest) // 买入、卖出或不买卖
```
最终的答案就是dp[n-1][m][0]，即最后一天且不持有股票所获得的收益，注意k取最大值<br>
注意到一直都是同一支股票，dp的递推关系为：
```
// 第i天不持有股票的情况有两种：前一天没有股票，今天不买； 或前一天有股票，今天卖了；选择收益最大的做法即可
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i])
// 第i天持有股票的情况，与上边类似: 前一天有股票， 今天不卖，或前一天没有股票，今天买入； 买入则收益减少prices[i]     
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])   
```

注意买入我们会将k减去1，卖出则不会；改成卖出时k-1，而买入时不变也是可以的<br>
那么初始情况如何确定？<br>
考虑第0天的情况确定初始值
```
dp[0][k][0] = 0 // 不买
dp[0][k][1] = -prices[0] // 买
```
另外需考虑k=1的情况
```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + price[i])
dp[i][1][1] = max(dp[i-1][0][0] - prices[i], dp[i-1][1][1])
            = max(-prices[i], dp[i-1][1][1])
```
或者如下情况表示初始状态
```
// i从0开始，-1代表还没开始
dp[-1][k][0] = 0 
dp[-1][k][1] = -infinity
```
k=0时会怎么样？
```
// k==0意味着不允许交易
dp[i][0][0] = 0
dp[i][0][1] = -infinity
```
数组索引-1及-infinity如何表示？<br>
数组可以比实际需要的长度多一个元素，-infinity用math.MinInt32表示
以上分析是把买入看出一次交易，卖出不算得到；如果把买入后再卖出才算一次交易，是类似的，只是初始条件的确定稍微麻烦点，详见iv.go

## 题解列表
[121. 买卖股票的最佳时机](i.go)<br>
[剑指 Offer 63. 股票的最大利润](i.go)<br>
[122. 买卖股票的最佳时机 II](ii.go)<br>
[309. 最佳买卖股票时机含冷冻期](iicooldown.go)<br>
[714. 买卖股票的最佳时机含手续费](iifee.go)<br>
[123. 买卖股票的最佳时机 III](iii.go)<br>
[188. 买卖股票的最佳时机 IV](iv.go)<br>

## 拓展
如果对于每个时间点，都可以买入1次，同时可以卖出之前持有的任意多个股票，该如何计算？<br>
可以找出全局最高点，然后将最左边的y轴看成无限高的点（或看成另一个最高点）， 问题转化为[接雨水问题](../trapping-rain-water/d.go)
