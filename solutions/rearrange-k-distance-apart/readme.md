# 重排使相同元素至少间隔k
## [621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)
```text
给定一个用字符数组表示的 CPU 需要执行的任务列表。
其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。
任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。
CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。

然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，
因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的最短时间。 

示例 ：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，
而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 
 

提示：
任务的总个数为 [1, 10000]。
n 的取值范围为 [0, 100]。
```
一般思路
```text
先统计每个任务的数量，贪心策略，需要先安排数量大的任务
以n+1个任务为一轮，同一轮中一个任务最多被安排一次。
每一轮中，将当前任务按照剩余次数降序排列，再选择剩余次数最多的n+1个任务一次执行
如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。

时间复杂度: O(result),给每个任务都安排了时间，因此时间复杂度和最终的答案成正比
空间复杂度: O(26)=O(1)
```
```go
func leastInterval(tasks []byte, n int) int {
	count := make([]int, 26)
	for _, v := range tasks {
		count[v-'A']++
	}
	sort.Sort(sort.Reverse(sort.IntSlice(count)))
	result := 0
	for count[0] > 0 {
		for i := 0; i <= n && count[0] > 0; i++ {
			result++
			if i < 26 && count[i] > 0 {
				count[i]--
			}
		}
		sort.Sort(sort.Reverse(sort.IntSlice(count)))
	}
	return result
}
```
另有两个解法，详见[参考代码](task_schedule.go)
## [358. K 距离间隔重排字符串](https://leetcode-cn.com/problems/rearrange-string-k-distance-apart/)
```text
给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，
使得重排后的字符串中相同字母的位置间隔距离至少为 k。
所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 ""。

示例 1：
输入: s = "aabbcc", k = 3
输出: "abcabc" 
解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。

示例 2:
输入: s = "aaabc", k = 3
输出: "" 
解释: 没有办法找到可能的重排结果。

示例 3:
输入: s = "aaadbbcc", k = 2
输出: "abacabcd"
解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。
```
类似问题621一般思路，详见[参考代码](rearrange_k.go)
## [767. 重构字符串](https://leetcode-cn.com/problems/reorganize-string/)
```text
767. 重构字符串
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。
若可行，输出任意可行的结果。若不可行，返回空字符串。

示例 1:
输入: S = "aab"
输出: "aba"

示例 2:
输入: S = "aaab"
输出: ""

注意:
S 只包含小写字母并且长度在[1, 500]区间内。
```
问题358变体，k==2的特例；另有其他解法，详见 [参考代码](rearrange_2.go)