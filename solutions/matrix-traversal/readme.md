# 遍历二维矩阵
对于二维矩阵，可以按照有趣的顺序遍历， 如下所示的“方形水波”、螺旋、对角线等几种遍历方法。
基本上都有一个比较好实现的哈希表解法，另有一个非常精确的遍历解法。
## [[1030]方形水波遍历](https://leetcode-cn.com/problems/matrix-cells-in-distance-order)
```text
给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。
另外，我们在该矩阵中给出了一个坐标为 (r0, c0) 的单元格。

返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，
其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。
（你可以按任何满足此条件的顺序返回答案。）

示例 1：
输入：R = 1, C = 2, r0 = 0, c0 = 0
输出：[[0,0],[0,1]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1]

示例 2：
输入：R = 2, C = 2, r0 = 0, c0 = 1
输出：[[0,1],[0,0],[1,1],[1,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]
[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。

示例 3：
输入：R = 2, C = 3, r0 = 1, c0 = 2
输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]
解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]
其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。
 
提示：
1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C
```
可以借助哈希表，键为各个点到给定点的曼哈顿距离，值为那些点的集合；也可以一股脑将各个点加入结果后再排序<br>
最好的也是最直观的解决方法，可以起一个名字：方形水波遍历：
```text
从(r0, c0)出发，按照曼哈顿距离向外扩展，可以看到对于曼哈顿距离为定值的点，连接起来是一个旋转了45°的正方形，当然正方形的中心是（r0，c0）
可以将这些正方形形象地称作方形水波~
实际就是从(r0, c0)出发，从内向外层层遍历那些方形水波
对于每个方形水波，有上下左右4个顶点，
每次可以先从上顶点开始顺时针遍历，先遍历到右顶点，再遍历到下顶点，再到左顶点，最后回归上顶点；
当然这道题对顺序没有要求，可以从任意顶点开始，顺、逆时针遍历都行
注意方形水波的某些点可能超出矩阵范围，处理好边界即可

时空复杂度都是O(R*C)。
时间上，会有一些超出矩阵的点去遍历，但总的量级在R*C；
空间复杂度主要在最后的结果数组上，这是没法省的，除去结果数组，方形水波遍历的解法显然是常数级的空间复杂度
```
参考[代码实现](manhaton.go)
## [[54] 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix)
```text
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

示例 1:
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]

示例 2:
输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]
```
参考[代码实现](spiral.go)

## [[59] 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii)
```text
给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3
输出:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```
与上个问题54非常类似

参考[代码实现](spiralII.go)

## [[885] 螺旋矩阵 III](https://leetcode-cn.com/problems/spiral-matrix-iii)
```text
在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始

这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。

现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。

每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。

最终，我们到过网格的所有 R * C 个空间。

按照访问顺序返回表示网格位置的坐标列表。 

示例 1：
输入：R = 1, C = 4, r0 = 0, c0 = 0
输出：[[0,0],[0,1],[0,2],[0,3]]
 

示例 2：
输入：R = 5, C = 6, r0 = 1, c0 = 4
输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]


提示：
1 <= R <= 100
1 <= C <= 100
0 <= r0 < R
0 <= c0 < C
```
参考[代码实现](spiralIII.go)

## [[498] 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse)
```text
给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:


说明:

给定矩阵中的元素总数不会超过 100000 。
```
参考[代码实现](diagonal.go)